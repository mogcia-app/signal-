# 月次レポート：シンプル化提案（更新版）

## エンドポイント設計（最終版）

### 案1: 2つのエンドポイント（推奨）

```
1. GET /api/analytics/performance-score?date=2025-11
   - パフォーマンス評価スコア（A〜F）
   - パラメータ: date (必須, YYYY-MM形式)
   - 月次のみ（weekly不要）

2. GET /api/analytics/pdca-execution-rate?date=2025-11
   - PDCA実行度（％）
   - パラメータ: date (必須, YYYY-MM形式)
   - 月次のみ（weekly不要）
```

### 案2: 1つのエンドポイント

```
GET /api/analytics/evaluation?date=2025-11
   - パフォーマンス評価スコア + PDCA実行度
   - パラメータ: date (必須, YYYY-MM形式)
   - 月次のみ（weekly不要）
```

## 実装イメージ（更新版）

### パフォーマンス評価スコアAPI
```typescript
// src/app/api/analytics/performance-score/route.ts
export async function GET(request: NextRequest) {
  const { uid } = await requireAuthContext(request);
  const { searchParams } = new URL(request.url);
  const date = searchParams.get("date"); // YYYY-MM形式（例: "2025-11"）
  
  if (!date || !/^\d{4}-\d{2}$/.test(date)) {
    return NextResponse.json(
      { error: "date parameter is required (format: YYYY-MM)" },
      { status: 400 }
    );
  }
  
  // 1. 月の範囲を計算
  const [year, month] = date.split("-").map(Number);
  const start = new Date(year, month - 1, 1);
  const end = new Date(year, month, 0, 23, 59, 59, 999);
  
  // 2. 必要なデータを取得（並列）
  const [analytics, posts, plans] = await Promise.all([
    // 期間内の分析データ（KPI計算用）
    adminDb.collection("analytics")
      .where("userId", "==", uid)
      .where("publishedAt", ">=", admin.firestore.Timestamp.fromDate(start))
      .where("publishedAt", "<=", admin.firestore.Timestamp.fromDate(end))
      .get(),
    
    // 期間内の投稿数
    adminDb.collection("posts")
      .where("userId", "==", uid)
      .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(start))
      .where("createdAt", "<=", admin.firestore.Timestamp.fromDate(end))
      .get(),
    
    // 計画の有無
    adminDb.collection("plans")
      .where("userId", "==", uid)
      .where("snsType", "==", "instagram")
      .where("status", "==", "active")
      .limit(1)
      .get()
  ]);
  
  // 3. KPIを集計
  const kpis = calculateKPIs(analytics.docs);
  
  // 4. スコアを計算
  const score = calculatePerformanceScore({
    postCount: posts.docs.length,
    analyzedCount: analytics.docs.length,
    hasPlan: !plans.empty,
    ...kpis
  });
  
  return NextResponse.json(score);
}
```

### PDCA実行度API
```typescript
// src/app/api/analytics/pdca-execution-rate/route.ts
export async function GET(request: NextRequest) {
  const { uid } = await requireAuthContext(request);
  const { searchParams } = new URL(request.url);
  const date = searchParams.get("date"); // YYYY-MM形式（例: "2025-11"）
  
  if (!date || !/^\d{4}-\d{2}$/.test(date)) {
    return NextResponse.json(
      { error: "date parameter is required (format: YYYY-MM)" },
      { status: 400 }
    );
  }
  
  // 1. 月の範囲を計算
  const [year, month] = date.split("-").map(Number);
  const start = new Date(year, month - 1, 1);
  const end = new Date(year, month, 0, 23, 59, 59, 999);
  
  // 2. 必要なデータを取得（並列）
  const [analytics, posts, plans] = await Promise.all([
    // 期間内の分析データ
    adminDb.collection("analytics")
      .where("userId", "==", uid)
      .where("publishedAt", ">=", admin.firestore.Timestamp.fromDate(start))
      .where("publishedAt", "<=", admin.firestore.Timestamp.fromDate(end))
      .get(),
    
    // 期間内の投稿数
    adminDb.collection("posts")
      .where("userId", "==", uid)
      .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(start))
      .where("createdAt", "<=", admin.firestore.Timestamp.fromDate(end))
      .get(),
    
    // 計画の有無
    adminDb.collection("plans")
      .where("userId", "==", uid)
      .where("snsType", "==", "instagram")
      .where("status", "==", "active")
      .limit(1)
      .get()
  ]);
  
  // 3. PDCA実行度を計算
  const rate = calculatePDCAExecutionRate({
    postCount: posts.docs.length,
    analyzedCount: analytics.docs.length,
    hasPlan: !plans.empty
  });
  
  return NextResponse.json({ rate });
}
```

## 変更点まとめ

### 削除
- ❌ `period` パラメータ（`"weekly" | "monthly"`）
- ❌ 週次計算ロジック
- ❌ 週次フィルタリング

### 簡素化
- ✅ `date` パラメータのみ（`YYYY-MM`形式）
- ✅ 月次計算のみ
- ✅ シンプルな実装

## メリット

1. **さらにシンプル**: パラメータが1つだけ
2. **実装が簡単**: 週次ロジックが不要
3. **バグが減る**: 複雑な条件分岐が不要
4. **テストが簡単**: テストケースが減る

