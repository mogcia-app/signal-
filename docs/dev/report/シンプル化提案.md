# 月次レポート：シンプル化提案

## 現状の問題

現在の月次レポートは：
- **7つのAPIルート**
- **12個以上のコレクションアクセス**
- **複雑な依存関係**
- **8種類のインデックスが必要**

## 提案：シンプルな設計

### 1. パフォーマンス評価スコア

**必要なデータ**:
- 投稿数（期間内）
- 分析済み数（期間内）
- 計画の有無（planで計画立てたかどうか）
- 今月の総合KPI
  - いいね数
  - リーチ数
  - 保存数
  - コメント数

**計算ロジック**:
```typescript
function calculatePerformanceScore(params: {
  postCount: number;
  analyzedCount: number;
  hasPlan: boolean;
  totalLikes: number;
  totalReach: number;
  totalSaves: number;
  totalComments: number;
}): { score: number; rating: "S" | "A" | "B" | "C" | "D" | "F" } {
  // 独自ロジックで計算
  // A〜F評価を返す
}
```

**必要なインデックス**:
- `analytics`: `userId` (ASC) + `publishedAt` (ASC) - 期間フィルタ用
- `posts`: `userId` (ASC) + `createdAt` (ASC) - 期間フィルタ用
- `plans`: `userId` (ASC) + `snsType` (ASC) + `status` (ASC) - 計画の有無確認用

### 2. PDCA実行度

**必要なデータ**:
- 投稿数（期間内）
- 分析済み数（期間内）
- 計画の有無（planで計画立てたかどうか）

**計算ロジック**:
```typescript
function calculatePDCAExecutionRate(params: {
  postCount: number;
  analyzedCount: number;
  hasPlan: boolean;
}): number {
  // ％評価で返す
  // 例: (analyzedCount / postCount) * 100
  // 計画がある場合はボーナス
}
```

**必要なインデックス**:
- パフォーマンス評価と同じ（追加不要）

## エンドポイント設計

### 案1: 2つのエンドポイント（推奨）

```
1. GET /api/analytics/performance-score?date=YYYY-MM
   - パフォーマンス評価スコア（A〜F）
   - 必要なデータのみ取得
   - 軽量で高速
   - パラメータ: date (必須, YYYY-MM形式)

2. GET /api/analytics/pdca-execution-rate?date=YYYY-MM
   - PDCA実行度（％）
   - 必要なデータのみ取得
   - 軽量で高速
   - パラメータ: date (必須, YYYY-MM形式)
```

### 案2: 1つのエンドポイント

```
GET /api/analytics/evaluation?date=YYYY-MM
   - パフォーマンス評価スコア + PDCA実行度
   - 1回のAPI呼び出しで両方取得
   - パラメータ: date (必須, YYYY-MM形式)
```

## 必要なインデックス（最小限）

### 1. `analytics` コレクション
```json
{
  "collectionGroup": "analytics",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "userId", "order": "ASCENDING" },
    { "fieldPath": "publishedAt", "order": "ASCENDING" }
  ]
}
```
**用途**: 期間内の分析データ取得（KPI計算用）

### 2. `posts` コレクション
```json
{
  "collectionGroup": "posts",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "userId", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "ASCENDING" }
  ]
}
```
**用途**: 期間内の投稿数取得

### 3. `plans` コレクション
```json
{
  "collectionGroup": "plans",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "userId", "order": "ASCENDING" },
    { "fieldPath": "snsType", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```
**用途**: 計画の有無確認

**合計: 3つのインデックス**（現在の8種類から大幅削減）

## コード構造

```
src/app/api/analytics/
├── performance-score/
│   └── route.ts          # パフォーマンス評価スコア計算
├── pdca-execution-rate/
│   └── route.ts          # PDCA実行度計算
└── utils/
    ├── score-calculator.ts    # スコア計算ロジック
    └── pdca-calculator.ts     # PDCA計算ロジック
```

**合計: 5ファイル程度**（現在の複雑な構造から大幅削減）

## データ取得の最適化

### 現状（非効率）
```typescript
// 全件取得してからクライアント側でフィルタリング
const allAnalytics = await adminDb.collection("analytics")
  .where("userId", "==", uid)
  .get();  // ← 全件取得！

const filtered = allAnalytics.filter(item => {
  const date = new Date(item.publishedAt);
  return date >= startDate && date <= endDate;
});
```

### 改善後（効率的）
```typescript
// サーバー側で期間フィルタリング
const analytics = await adminDb.collection("analytics")
  .where("userId", "==", uid)
  .where("publishedAt", ">=", startDate)
  .where("publishedAt", "<=", endDate)
  .get();  // ← 必要なデータのみ取得

// 集計
const totalLikes = analytics.docs.reduce((sum, doc) => 
  sum + (doc.data().likes || 0), 0
);
```

## メリット

### 1. パフォーマンス
- **API呼び出し**: 7回 → 2回（または1回）
- **コレクションアクセス**: 12回 → 3回
- **データ転送量**: 大幅削減（必要なデータのみ取得）
- **ロード時間**: 大幅短縮

### 2. 保守性
- **コード量**: 大幅削減
- **複雑度**: 大幅削減
- **デバッグ**: 容易
- **テスト**: 容易

### 3. スケーラビリティ
- **インデックス**: 3つ（現在の8種類から削減）
- **サーバー負荷**: 大幅削減
- **コスト**: 大幅削減（Firestore読み取り回数削減）

## 実装イメージ

### パフォーマンス評価スコアAPI
```typescript
// src/app/api/analytics/performance-score/route.ts
export async function GET(request: NextRequest) {
  const { uid } = await requireAuthContext(request);
  const { date } = getParams(request); // YYYY-MM形式（例: "2025-11"）
  
  // 1. 期間を計算（月次のみ）
  const { start, end } = getMonthRange(date);
  
  // 2. 必要なデータを取得（並列）
  const [analytics, posts, plans] = await Promise.all([
    // 期間内の分析データ（KPI計算用）
    adminDb.collection("analytics")
      .where("userId", "==", uid)
      .where("publishedAt", ">=", start)
      .where("publishedAt", "<=", end)
      .get(),
    
    // 期間内の投稿数
    adminDb.collection("posts")
      .where("userId", "==", uid)
      .where("createdAt", ">=", start)
      .where("createdAt", "<=", end)
      .get(),
    
    // 計画の有無
    adminDb.collection("plans")
      .where("userId", "==", uid)
      .where("snsType", "==", "instagram")
      .where("status", "==", "active")
      .limit(1)
      .get()
  ]);
  
  // 3. KPIを集計
  const kpis = calculateKPIs(analytics.docs);
  
  // 4. スコアを計算
  const score = calculatePerformanceScore({
    postCount: posts.docs.length,
    analyzedCount: analytics.docs.length,
    hasPlan: !plans.empty,
    ...kpis
  });
  
  return NextResponse.json(score);
}
```

### PDCA実行度API
```typescript
// src/app/api/analytics/pdca-execution-rate/route.ts
export async function GET(request: NextRequest) {
  const { uid } = await requireAuthContext(request);
  const { date } = getParams(request); // YYYY-MM形式（例: "2025-11"）
  
  // 1. 期間を計算（月次のみ）
  const { start, end } = getMonthRange(date);
  
  // 2. 必要なデータを取得（並列）
  const [analytics, posts, plans] = await Promise.all([
    // 期間内の分析データ
    adminDb.collection("analytics")
      .where("userId", "==", uid)
      .where("publishedAt", ">=", start)
      .where("publishedAt", "<=", end)
      .get(),
    
    // 期間内の投稿数
    adminDb.collection("posts")
      .where("userId", "==", uid)
      .where("createdAt", ">=", start)
      .where("createdAt", "<=", end)
      .get(),
    
    // 計画の有無
    adminDb.collection("plans")
      .where("userId", "==", uid)
      .where("snsType", "==", "instagram")
      .where("status", "==", "active")
      .limit(1)
      .get()
  ]);
  
  // 3. PDCA実行度を計算
  const rate = calculatePDCAExecutionRate({
    postCount: posts.docs.length,
    analyzedCount: analytics.docs.length,
    hasPlan: !plans.empty
  });
  
  return NextResponse.json({ rate });
}
```

## 次のステップ

1. **インデックス追加**: 3つのインデックスを追加
2. **API実装**: 2つのエンドポイントを実装
3. **フロントエンド更新**: 新しいAPIを使用するように更新
4. **既存APIの削除**: 不要になったAPIを削除

## 結論

ユーザーの提案は**非常に合理的**です。

- **シンプル**: 必要なデータのみ取得
- **高速**: 最小限のコレクションアクセス
- **保守性**: コード量が大幅削減
- **スケーラブル**: インデックスも最小限

この設計で実装すれば、現在の複雑さを大幅に削減できます。

